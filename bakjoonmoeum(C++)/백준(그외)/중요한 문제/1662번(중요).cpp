#include <iostream>
#include <stack>
#include <string>
#include <cctype>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    stack <int> st;
    string input;
    int total = 0;
    cin >> input;

    for(int i = 0;i<input.length();i++){
        if(input[i] == '('){//여는 괄호면 -1 대입**
            st.push(-1);
        }else if(isdigit(input[i])){//숫자면
            if(i < input.length() - 1 && input[i+1] == '('){//앞에 괄호면 그대로, 아니면 1을 넣어준다.
                st.push(input[i] - '0');
            }else{
                st.push(1);
            }
        }else if(input[i] == ')'){//여는 괄호 찾을 때까지 지우면서 cnt++
            int cnt = 0;
            while(st.top() != -1){
                cnt += st.top();
                st.pop();
            }
            st.pop();
            cnt *= st.top();//곱해주고
            st.pop();
            st.push(cnt);//재활용해야하므로 스택에 재삽입
        }
    }
    while(!st.empty()){
        total += st.top();
        st.pop();
    }
    cout << total;
}
/*
과정 요약:
1. 스택에 괄호 문자를 그대로 넣지 않고 열린 괄호를 -1의 정수로 넣어준다. 
2. 숫자면 2가지 경우가 있다. 
2-1. 숫자 뒤에 열린 괄호면 숫자를 그대로 스택에 삽입해준다. 
2-2. 그렇지 않으면 숫자 자체는 의미가 없으므로 길이로서 역할을 하는 1을 삽입해준다. 
3. 닫힌 괄호를 만나면 열린 괄호를 만날때까지 스택에서 1씩 지우면서 cnt++한다. 
3-1. 열린괄호를 만나면 중지하고 다시 한 번 pop한다. (열린 괄호를 지우는 역할)
3-2. top에 있는 숫자를 cnt와 곱해준다.
3.3. 다시 pop을 하고 스택에 cnt를 재삽입해준다. (전역변수일 경우 cnt = 0)
4. 이 과정을 반복하고 스택에 남아있는 수를 모두 더해 출력한다.

틀린 이유: 처음 생각한 방법은 위와 비슷하게 닫힌 괄호를 만날때까지 스택에 넣고, 
닫힌 괄호가 보이면 열린 괄호를 만날때까지 cnt++ 후, 만나면 앞의 수를 곱해주는 형식까지는 똑같았다.
하지만 문제는 1(9)2(9) 같이 같은 레벨의 괄호가 여러개 존재하면 그것 또한 곱해버려서 틀리는 현상이 발생했다. 이것의 주 원인은 계산한 수를 스택에 다시 넣지 않고 단순히 누적하려고만 한 문제였다. 

비슷한 유형의 문제로 "2504번 괄호의 값"이 있다.

한 마디 요약: 괄호 포함, 수 누적 등의 비슷한 문제는 괄호 등의 문자를 직접 자료구조에 넣기보다,
숫자로 변환 가능하면 숫자로 변환하여 삽입하고, 스택에 반복할 때마다 계산된 값을 자료구조에 삽입하여
자연스러운 계산을 유도하도록 하자.

33(562(71(9)))
13(112(11(1)))
13(112(11)) 1
13(114) 4
118 
19

1(1)2(1)
12(1)
3
*/