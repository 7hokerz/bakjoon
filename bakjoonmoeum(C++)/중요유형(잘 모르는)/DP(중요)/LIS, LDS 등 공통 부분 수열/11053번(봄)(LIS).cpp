#include <iostream>
using namespace std;
/*
LIS: 최장 증가 부분 수열(오름차순으로 구성 가능한 원소들을 선택하여 최대 길이를 찾아내는 것)
dp[]: 인덱스의 요소를 포함하는 부분 수열의 최대 길이 저장

수열의 값: 10 20 10 30 20 50
dp에 저장된 요소: 1 2 1 3 2 4

이해:
1. 우선 10일 때는 값이 1이 된다. 자기 자신 또한 길이 1인 부분 수열이기 때문
2. 20일 때는 증가하므로 값이 2가 된다.
3. 10일 때는 앞의 값이 더 크므로 다시 길이는 1이 된다.
4. 30일 때는 앞의 10 20을 더해서 총 길이가 3이 된다.
5. 20일 때는 앞의 값이 더 크므로 길이는 1이 된다.
6. 50일 때는 앞의 10 20 30을 더해서 총 길이가 4가 된다.

1. 탑다운 방식(재귀)(꼭대기에서 처음까지 내려가는 방식)
탐색하려는 현 위치에서 이전 위치들을 찾아나가면서 현 위치의 값보다 작을 경우 재귀 호출 한다.(dp배열에서 값을 불러온다는 뜻)
이유: 
dp에는 아까 말했듯이 해당 요소보다 더 작은 수. 즉 증가 부분 수열을 만족하는 요소의 개수를 저장하고 있다.
그런데 현 위치의 값보다 작은 값을 발견했다는 것은? 
"현 위치를 포함하는 LIS를 만족하는 수열"을 찾았다는 이야기다.

**그런데 재귀 함수 + 1인 이유? 당연하다. 
재귀 호출로 반환되는 값은 현 위치 요소를 제외한 나머지 길이이다. 그러므로 현 위치를 포함하려면 +1을 해줘야 한다.

2. 바텀업 방식(반복문)(처음부터 꼭대기까지)
처음부터 다음 위치를 찾아나가면서 더 값이 큰 경우를 탐색한다.
**dp[i] < dp[j] + 1의 조건을 추가한 이유?
재귀 호출과 같은 느낌으로 보면 된다. dp[i]는 현재 요소이고, dp[j]는 dp[i]보다 큰 수.
dp[i]가 더 클 수도 있을지 모르니까 최대 길이만을 뽑으려면 저게 안전한거다 라고 생각하자.
*/

int LIS(int n, int dp[], int inp[]){
    //탐색하지 않은 위치인 경우 dp[n] 1로 초기화(자기 자신의 길이는 1이기 때문)
    if(dp[n] == 0){
        dp[n] = 1;
        //n-1부터 0까지 돌면서 n(idx)보다 더 작은 값이 존재하면 재귀 함수를 호출시킨다.(결국 dp[i]에 저장된 값을 불러오게 된다.)
        for(int i = n-1;i>=0;i--){
            if(inp[i] < inp[n]){
                dp[n] = max(dp[n], LIS(i, dp, inp) + 1);//사실 LIS 재귀를 쓰지 않아도 답은 맞다.
            }
        }
    }
    return dp[n];//dp에 저장된 값이 존재하면 바로 리턴된다.
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    int n, input;
    cin >> n;
    int dp[n], inp[n];
    for(int i = 0;i<n;i++){
        cin >> input;
        inp[i] = input;
        dp[i] = 0;
    }
    //처음부터 끝까지 완전탐색하여 dp배열을 갱신한다.
    /*for(int i = 0;i<n;i++){
        LIS(i, dp, inp);
    }*/

    for(int i = 0;i<n;i++){
        dp[i] = 1;//탐색되지 않은 경우 1로 초기화
        for(int j = 0;j<i;j++){
            if(inp[j]<inp[i] && dp[i]<dp[j]+1){
                dp[i] = dp[j] + 1;
            }
        }
    }

    int max = dp[0];
    for(int i = 1;i<n;i++){//최댓값을 찾는다.
        max = (dp[i]>max)?dp[i]:max;
    }
    cout << max;
}
