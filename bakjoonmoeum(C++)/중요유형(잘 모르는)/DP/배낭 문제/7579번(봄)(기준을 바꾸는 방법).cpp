#include <iostream>
#include <vector>
using namespace std;
int N, M, input, mx = 0;
//기준을 바꿨다
int dp[101][10001];//N번째 앱까지 탐색하였을 때 c의 비용을 지불하여 얻을 수 있는 최대 메모리

int app[101];//앱이 사용 중인 메모리 바이트
int charg[101];//비활성화 시 비용

void calc(int pos){
    for(int i = 0;i<mx+1;i++){
        if(i>=charg[pos]){//이 조건들 자체는 배낭 문제와 동일하다.
            //비활성화하지 않을 경우, 비활성화 하는 경우로 나뉨
            //어떤 비용을 지불하고 남는 비용으로 쓸 수 있는 최대 메모리
            dp[pos][i] = max(dp[pos-1][i], app[pos] + dp[pos-1][i-charg[pos]]);
        }
        else{
            dp[pos][i] = dp[pos-1][i];
        }
    }
}

int main(){
    ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> N >> M;
    for(int i = 1;i<N+1;i++){
        cin >> input;
        app[i] = input;
    }
    for(int i = 1;i<N+1;i++){
        cin >> input;
        charg[i] = input;
        mx += input;//모든 비용의 합(최대 배열 검사 기준으로 삼음)
    }
    for(int i = 1;i<N+1;i++){
        calc(i);
    }
    int res = mx;
    for(int i = 1;i<N+1;i++){
        for(int j = 0;j<mx+1;j++){
            if(dp[i][j] >= M){//조건을 만족하는 경우 중 최소 비용을 출력한다.
                res = (res>j)?j:res;
            }
            //cout << dp[i][j] << ' ';
        }
        //cout << '\n';
    }
    cout << res;
}   
/*
다른 배낭 문제는 보통 일정 값을 넘어선 안되는 경우고, 최대값을 구한다. 하지만 이 문제는 일정 값 이상이어야 하는 경우고, 최소값을 구한다.
다른 블로그 참고. "비용에 따른 바이트"로 생각해보자!
일단 방법을 보고 최대한 생각해서 풀었다...방법 보고 하는데도 시간이 너무 오래걸린다 ㅅㅂ


일반 배낭 문제와 다른 점
위에 써있듯이, 원래의 조건은 정해진 수 이하를 담으면서 최댓값을 구해야 한다.
하지만 이 문제는 어떤 조건 이상을 만족하면서 비용에 대한 최솟값을 구하라는 경우다.

이럴 땐 똑같이 풀면 절대로 구할 수 없고, 기준을 바꿔주어야 한다. 
원래 같으면 바이트 = 무게, 비용 = 최대 가치 로 잡고 푸는데, 

기준을 바꿔서 비용 = 무게, 바이트 = 최대 가치로 잡고 풀어보자.
이런 경우 어떻게 해야 할까?

행에는 똑같이 앱의 번호, 열에는 비용을 기준으로 잡으면 되고, dp에 들어갈 값은 최대 바이트가 될 것이다.
비용은? 앱의 비용을 전부 합한 값까지만 조사하면 된다.

모두 조사를 마치면 이 때 바이트값이 M과 같거나 넘는 경우를 찾은 후, 이 중에서 최솟값을 구하면 된다.

(몇 번 반복해서 봐야 겨우 눈에 익겠네...ㅅㅂ)
*/